#!/bin/bash
#
## This heavily commented Bash script acts as a template for writing Bash scripts
## while simultaneously setting up an environment for bioinformatics projects.

usage()
{
	printf "Usage: %s [options]\n" "$0"
	printf "Options:\n"
	printf "  -h, --help    Show this help message and exit\n"
	printf "  -v, --verbose Enable verbose output\n"
	printf "  -d DIR        Specify a directory\n"
	# Add more options and their descriptions here
}

# Safety first! We can set some options to make the script "safer".
# Use `set` to set shell options so that invoking the script
# with `bash <script_name>` does not break the script.

# Exit immediately if a command exits with a non-zero status.
# This is the same as `set -e`. Append "|| true" if you expect an error.
set -o errexit

# Do not allow use of undefined variables. Same as `set -u`.
set -o nounset

# Define functions like this (without the `function` keyword)
err()
{
	printf "Error [%s]: %s\n" "$(date +'%Y-%m-%dT%H:%M:%S%z')" "$*" >&2
}

# Function to print the error and exit with a non-zero status
bail()
{
	err "$*"
	exit 1
}

# Catch the error in case a pipeline element fails (returns non-zero)
# Note that this does not catch every error, but a script that works
# with `set -o pipefail` will always work without it, while the opposite is not true.
# Note that `set -o pipefail` is not POSIX-compliant, so we can add a check for POSIX mode.
if [ "${POSIXLY_CORRECT:-}" != "" ]; then
	err "POSIXLY_CORRECT is set; some features may be disabled"
else
	set -o pipefail
fi

check_bash_version()
{
	if [ "${BASH_VERSINFO[*]}" = "" ] || [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
		bail "Bash version 4 or later is required"
	fi
}

# Uncomment to print each command before it is executed. Useful for debugging.
# This is the same as `set -x` or invoking the script with `bash -x`.
# set -o xtrace

# Global variables
SCRIPTS_DIR=$(cd "$(dirname "$0")" && pwd)
GENOMES_DIR="$SCRIPTS_DIR/../genomes"

# Declare and assign variables separately to avoid masking errors
export SCRIPTS_DIR
export GENOMES_DIR

# Optionally, add the script directory to the PATH
# PATH="${SCRIPTS_DIR}:${PATH}"
# echo "export PATH=\"${SCRIPTS_DIR}:\$PATH\"" >> "$HOME/.bashrc"

# Or set an alias
# echo "alias $0='${SCRIPTS_DIR}/$0'" >> "$HOME/.bashrc"

# Set up genomes: download files with wget
init_mouse_genome() {
    URL="https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/635/GCA_000001635.9_GRCm39/seqs_for_alignment_pipelines.ucsc_ids"
    FILES=$(curl -s "$URL/" | grep -oP '(?<=href=")[^"]*' | grep -v '/$')

    mkdir -p "$GENOMES_DIR/mouse"

    for f in $FILES; do
	wget -q --no-parent --no-directories -P "$GENOMES_DIR/mouse" "$URL/$f" &
    done
    echo "Downloading mouse genome. This may take a while..."
    wait
    "$SCRIPTS_DIR"/SUCCESS

    # TODO: Extract the files
    # TODO: compress the fai with bgzip
}

# demultplex Illumina sequencing data with bcl2fastq
# assumes that the run folder contains ## a valid SampleSheet.csv
# TODO: copy the binary to aws s3 so that it can be downloaded if unavailable
demultiplex_bcl2fastq()
{
	local run_folder=$1
	local output_folder=$2

	# run bcl2fastq with the same flags as a default NextSeq run
	bcl2fastq --no-lane-splitting \
		--ignore-missing-bcls \
		--ignore-missing-filter \
		--ignore-missing-positions \
		--ignore-missing-controls \
		--auto-set-to-zero-barcode-mismatches \
		--find-adapters-with-sliding-window \
		--adapter-stringency 0.9 \
		--mask-short-adapter-reads 35 \
		--minimum-trimmed-read-length 35 \
		-R "$run_folder" \
		-o "$output_folder"
	# --sample-sheet "$sample_sheet" \
	echo "Demultiplexing complete"
}

# Call main function
align_reads() {
    local aligner="$1" r1_fastq="$2" r2_fastq="$3" reference="$4"
    local align_opts="-p $(nproc) --mm -1 $r1_fastq -2 $r2_fastq -x $reference"
    case "$aligner" in
        hisat2) hisat2 $align_opts ;;
        bowtie2) bowtie2 $align_opts --dta ;;
        *) bail "Invalid aligner: $aligner" ;;
    esac
}

align_to_bam() {
    local aligner="$1" r1_fastq="$2" r2_fastq="$3" reference="$4"
    local bam_file="${r1_fastq%_R1*}_sorted_markdup.bam"
    align_reads "$aligner" "$r1_fastq" "$r2_fastq" "$reference" |
        samtools sort -n -@ "$(nproc)" - |
        samtools fixmate -@ "$(nproc)" -m - - |
        samtools sort -@ "$(nproc)" - |
        samtools markdup -@ "$(nproc)" - "$bam_file"
}

bam_to_cram() {
    local bam_file="$1"
    local id=$(basename "$bam_file" .bam)
    local cram_file="${id}.cram"
    local reference="/home/ubuntu/genomes/human/GCA_000001405.15_GRCh38_full_analysis_set.fna.bgz"
    samtools view -@"$(nproc)" --cram -T "$reference" "$bam_file" > "$cram_file"
    pr_info "Converted $bam_file to $cram_file"
}

cram_to_bam() {
    local cram_file="$1"
    local id=$(basename "$cram_file" .cram)
    local bam_file="${id}.bam"
    [ -f "$bam_file" ] && mv "$bam_file" "${bam_file}.bak"
    samtools view -@"$(nproc)" --bam "$cram_file" > "$bam_file"
    pr_info "Converted $cram_file to $bam_file"
}

run_fastqc() {
    local out_dir=${1:-fastqc}
    local memsize=4096
    mkdir -p "$out_dir"
    fastqc -t "$(nproc)" --memory "$memsize" --noextract -o "$out_dir" ./*
    pr_info "FastQC analysis completed. Results in $out_dir"
}

cmd_align() {
    local species aligner input_dir output_dir
    while getopts ":s:a:i:o:h" opt; do
        case $opt in
            s) species=$OPTARG ;;
            a) aligner=$OPTARG ;;
            i) input_dir=$OPTARG ;;
            o) output_dir=$OPTARG ;;
            h) cmd_align_help; return 0 ;;
            \?) bail "Invalid option: -$OPTARG" ;;
        esac
    done

    [ -z "$species" ] && bail "Species (-s) is required for alignment"
    [ -z "$aligner" ] && bail "Aligner (-a) is required for alignment"
    [ -z "$input_dir" ] && bail "Input directory (-i) is required"
    [ -z "$output_dir" ] && bail "Output directory (-o) is required"

    validate "$species" "$VALID_SPECIES" || bail "Invalid species: $species"
    validate "$aligner" "$VALID_ALIGNERS" || bail "Invalid aligner: $aligner"

    local reference="$GENOMES_DIR/${species}/${species}_genome"
    mkdir -p "$output_dir"

    for r1_fastq in "$input_dir"/*_R1.fastq.gz; do
        r2_fastq="${r1_fastq/_R1/_R2}"
        [ -f "$r2_fastq" ] || bail "Paired read file not found: $r2_fastq"
        align_to_bam "$aligner" "$r1_fastq" "$r2_fastq" "$reference"
    done

    pr_info "Alignment completed. BAM files are in $output_dir"
}

cmd_help() {
    cat << EOF
Usage: $(basename "$0") <command> [options] [arguments]

Commands:
  align         Perform sequence alignment
  init          Initialize genome files
  qc            Perform quality control
  convert       Convert between BAM and CRAM formats
  help          Show this help message

Run '$(basename "$0") help <command>' for more information on a specific command.
EOF
}

cmd_align_help() {
    cat << EOF
Usage: $(basename "$0") align [options]

Perform sequence alignment.

Options:
  -s SPECIES    Specify species (human or mouse)
  -a ALIGNER    Specify aligner ($VALID_ALIGNERS)
  -i INPUT      Input directory containing FASTQ files
  -o OUTPUT     Output directory for alignment results
  -h            Show this help message
EOF
}

main() {
    [ $# -eq 0 ] && { cmd_help; exit 1; }

    local cmd="$1"; shift
    case "$cmd" in
        align) cmd_align "$@" ;;
        init) init_genome "$@" ;;
        qc) run_fastqc "$@" ;;
        convert)
            [ $# -ne 1 ] && bail "Usage: $(basename "$0") convert <file.bam|file.cram>"
            case "$1" in
                *.bam) bam_to_cram "$1" ;;
                *.cram) cram_to_bam "$1" ;;
                *) bail "Unknown file type: $1" ;;
            esac
            ;;
        help)
            if [ $# -eq 0 ]; then
                cmd_help
            else
                case "$1" in
                    align) cmd_align_help ;;
                    init|qc|convert) pr_info "$1 help not yet implemented" ;;
                    *) bail "Unknown command: $1" ;;
                esac
            fi
            ;;
        *) bail "Unknown command: $cmd" ;;
    esac
}

main "$@"
